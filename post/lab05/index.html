<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Lab 05 - TCP Congestion Control and Fairness - COMP3331 Musings</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content=z5206677><meta name=description content="Exercise 0: Revision of TCP Congestion Control Name the loss events that occur at 1 and 2."><meta name=keywords content=Hugo,theme,even><meta name=generator content="Hugo 0.58.2 with theme even"><link rel=canonical href=../../post/lab05/><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../manifest.json><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><link href=../../dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=../../css/typedjs.shortcode.css><meta property=og:title content="Lab 05 - TCP Congestion Control and Fairness"><meta property=og:description content="Exercise 0: Revision of TCP Congestion Control Name the loss events that occur at 1 and 2."><meta property=og:type content=article><meta property=og:url content=/post/lab05/><meta property=article:published_time content=2020-04-05T18:36:40+10:00><meta property=article:modified_time content=2020-04-05T18:36:40+10:00><meta itemprop=name content="Lab 05 - TCP Congestion Control and Fairness"><meta itemprop=description content="Exercise 0: Revision of TCP Congestion Control Name the loss events that occur at 1 and 2."><meta itemprop=datePublished content=2020-04-05T18:36:40&#43;10:00><meta itemprop=dateModified content=2020-04-05T18:36:40&#43;10:00><meta itemprop=wordCount content=1600><meta itemprop=keywords content><meta name=twitter:card content=summary><meta name=twitter:title content="Lab 05 - TCP Congestion Control and Fairness"><meta name=twitter:description content="Exercise 0: Revision of TCP Congestion Control Name the loss events that occur at 1 and 2."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=../../ class=logo>COMP3331 Musings</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=../../><li class=mobile-menu-item>Home</li></a><a href=https://github.com/featherbear/UNSW-COMP3331><li class=mobile-menu-item>GitHub</li></a><a href=../../categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=../../ class=logo>COMP3331 Musings</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=../../>Home</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/featherbear/UNSW-COMP3331>GitHub</a></li><li class=menu-item><a class=menu-item-link href=../../categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Lab 05 - TCP Congestion Control and Fairness</h1><div class=post-meta><span class=post-time>2020-04-05</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#exercise-0-revision-of-tcp-congestion-control>Exercise 0: Revision of TCP Congestion Control</a><ul><li><a href=#name-the-loss-events-that-occur-at-1-and-2-explain-why-the-congestion-window-is-changed-differently-in-those-two-cases>Name the loss events that occur at 1 and 2. Explain why the congestion window is changed differently in those two cases.</a></li><li><a href=#what-phase-of-the-tcp-congestion-control-algorithm-coincides-with-the-circled-segment-marked-by-3-and-4>What phase of the TCP congestion control algorithm coincides with the circled segment marked by 3 and 4?</a></li><li><a href=#why-is-the-congestion-window-increased-more-rapidly-at-3-than-at-4>Why is the congestion window increased more rapidly at 3 than at 4?</a></li><li><a href=#what-happens-to-the-window-after-2>What happens to the window after 2?</a></li></ul></li><li><a href=#exercise-1-understanding-tcp-congestion-control-using-ns-2>Exercise 1: Understanding TCP Congestion Control using ns-2</a><ul><li><a href=#what-is-the-maximum-size-of-the-congestion-window-that-the-tcp-flow-reaches-in-this-case>What is the maximum size of the congestion window that the TCP flow reaches in this case?</a></li><li><a href=#what-does-the-tcp-flow-do-when-the-congestion-window-reaches-this-value-why-what-happens-next>What does the TCP flow do when the congestion window reaches this value? Why? What happens next?</a></li><li><a href=#calculate-the-average-throughput-in-packets-sec-and-bps>Calculate the average throughput (in packets/sec and bps)</a></li><li><a href=#rerun-the-above-script-each-time-with-different-values-for-the-max-congestion-window-size-but-the-same-rtt-i-e-100ms>Rerun the above script, each time with different values for the max congestion window size but the same RTT (i.e. 100ms).</a><ul><li><a href=#how-does-tcp-respond-to-the-variation-of-this-parameter>How does TCP respond to the variation of this parameter?</a></li><li><a href=#what-is-the-average-throughput-in-packets-and-bps-at-this-point>What is the average throughput (in packets and bps) at this point?</a></li><li><a href=#how-does-the-actual-average-throughput-compare-to-the-link-capacity-1mbps>How does the actual average throughput compare to the link capacity (1Mbps)?</a></li></ul></li></ul></li><li><a href=#exercise-1b-using-tcp-reno>Exercise 1b: Using TCP Reno</a><ul><li><a href=#what-is-the-maximum-size-of-the-congestion-window-that-the-tcp-flow-reaches-in-this-case-1>What is the maximum size of the congestion window that the TCP flow reaches in this case?</a></li><li><a href=#what-does-the-tcp-flow-do-when-the-congestion-window-reaches-this-value-why-what-happens-next-1>What does the TCP flow do when the congestion window reaches this value? Why? What happens next?</a></li><li><a href=#calculate-the-average-throughput-in-packets-sec-and-bps-1>Calculate the average throughput (in packets/sec and bps)</a></li><li><a href=#compare-the-graphs-for-the-two-implementations-and-explain-the-differences>Compare the graphs for the two implementations and explain the differences.</a></li></ul></li><li><a href=#exercise-2-flow-fairness-with-tcp>Exercise 2: Flow Fairness with TCP</a><ul><li><a href=#does-each-flow-get-an-equal-share-of-the-capacity-of-the-common-link-i-e-is-tcp-fair>Does each flow get an equal share of the capacity of the common link (i.e., is TCP fair)?</a></li><li><a href=#what-happens-to-the-throughput-of-the-pre-existing-tcp-flows-when-a-new-flow-is-created-explain-the-mechanisms-of-tcp-which-contribute-to-this-behaviour-argue-about-whether-you-consider-this-behaviour-to-be-fair-or-unfair>What happens to the throughput of the pre-existing TCP flows when a new flow is created? Explain the mechanisms of TCP which contribute to this behaviour. Argue about whether you consider this behaviour to be fair or unfair.</a></li></ul></li><li><a href=#exercise-3-tcp-competing-with-udp>Exercise 3: TCP competing with UDP</a><ul><li><a href=#how-do-you-expect-the-tcp-flow-and-the-udp-flow-to-behave-if-the-capacity-of-the-link-is-5-mbps>How do you expect the TCP flow and the UDP flow to behave if the capacity of the link is 5 Mbps?</a></li><li><a href=#test-your-hypothesis>Test your hypothesis</a></li><li><a href=#why-does-one-flow-achieve-higher-throughput-than-the-other-try-to-explain-what-mechanisms-force-the-two-flows-to-stabilise-to-the-observed-throughput>Why does one flow achieve higher throughput than the other? Try to explain what mechanisms force the two flows to stabilise to the observed throughput.</a></li><li><a href=#list-the-advantages-and-the-disadvantages-of-using-udp-instead-of-tcp-for-a-file-transfer-when-our-connection-has-to-compete-with-other-flows-for-the-same-link-what-would-happen-if-everybody-started-using-udp-instead-of-tcp-for-that-same-reason>List the advantages and the disadvantages of using UDP instead of TCP for a file transfer, when our connection has to compete with other flows for the same link. What would happen if everybody started using UDP instead of TCP for that same reason?</a><ul><li><a href=#advantages-udp-for-file-transfer>Advantages | UDP for file transfer</a></li><li><a href=#disadvantages-udp-for-file-transfer>Disadvantages | UDP for file transfer</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h1 id=exercise-0-revision-of-tcp-congestion-control>Exercise 0: Revision of TCP Congestion Control</h1><p><img src=tcp_cc.jpg alt></p><h2 id=name-the-loss-events-that-occur-at-1-and-2-explain-why-the-congestion-window-is-changed-differently-in-those-two-cases>Name the loss events that occur at 1 and 2. Explain why the congestion window is changed differently in those two cases.</h2><p>At 1: Duplicate ACK received - Window halved - Improves throughput<br>At 2: Timeout - Try again from start</p><h2 id=what-phase-of-the-tcp-congestion-control-algorithm-coincides-with-the-circled-segment-marked-by-3-and-4>What phase of the TCP congestion control algorithm coincides with the circled segment marked by 3 and 4?</h2><p>At 3: Slow Start (exponential increase)<br>At 4: AIMD (linear increase)</p><h2 id=why-is-the-congestion-window-increased-more-rapidly-at-3-than-at-4>Why is the congestion window increased more rapidly at 3 than at 4?</h2><p>(3) increases at an exponential rate.</p><h2 id=what-happens-to-the-window-after-2>What happens to the window after 2?</h2><p>The slow start algorithm starts again</p><h1 id=exercise-1-understanding-tcp-congestion-control-using-ns-2>Exercise 1: Understanding TCP Congestion Control using ns-2</h1><p><strong>Using TCP Tahoe&hellip;</strong></p><p>File: <a href=tpWindow.tcl>tpWindow.tcl</a><br>Usage: <code>ns tpWindow.tcl &lt;max_cwnd&gt; &lt;link_delay&gt;</code></p><p>File: <a href=Window.plot>Window.plot</a><br>Usage: <code>gnuplot Window.plot</code></p><blockquote><p>Run the script with the max initial window size set to 150 packets and the delay set to 100ms (be sure to type &ldquo;ms&rdquo; after 100).<br>In other words, type the following: <code>ns tpWindow.tcl 150 100ms</code>
&nbsp;<br>Then plot it with <code>gnuplot Window.plot</code></p></blockquote><p><img src="Screenshot from 2020-04-05 18-59-23.png" alt></p><h2 id=what-is-the-maximum-size-of-the-congestion-window-that-the-tcp-flow-reaches-in-this-case>What is the maximum size of the congestion window that the TCP flow reaches in this case?</h2><p>The maximum size is <code>100</code>.</p><h2 id=what-does-the-tcp-flow-do-when-the-congestion-window-reaches-this-value-why-what-happens-next>What does the TCP flow do when the congestion window reaches this value? Why? What happens next?</h2><p>When the congestion window reaches 100, the congestion window is set back to zero and the threshold is halved to 50 - the initial value where the TCP phase changes from a slow start algorithm to the AIMD (additive-increase / multiplicative-decrease) algorithm; so that the connection is kept in the congestion avoidance phase after a loss event.</p><p>After the congestion window size is set to zero, it begins to increase again (Slow Start) until it reaches 50; where the algorithm changes to AIMD.</p><h2 id=calculate-the-average-throughput-in-packets-sec-and-bps>Calculate the average throughput (in packets/sec and bps)</h2><p>File: <a href=WindowTPut.plot>WindowTPut.plot</a><br>Usage: <code>gnuplot WindowTPut.plot</code></p><p><img src="Screenshot from 2020-04-05 19-17-22.png" alt></p><p>The average throughput is around <code>185 packets per second</code>.</p><p>Average throughput (bps) = <code>185 * (500 + 20 + 20) * 8 = 799200 bps</code></p><h2 id=rerun-the-above-script-each-time-with-different-values-for-the-max-congestion-window-size-but-the-same-rtt-i-e-100ms>Rerun the above script, each time with different values for the max congestion window size but the same RTT (i.e. 100ms).</h2><blockquote><p>Find the value of the maximum congestion window at which TCP stops oscillating (i.e., does not move up and down again) to reach a stable behaviour.</p></blockquote><table><thead><tr><th align=center>150</th><th align=center>100</th><th align=center>60</th><th align=center>51</th><th align=center><strong>50</strong></th><th align=center>49</th><th align=center>40</th></tr></thead><tbody><tr><td align=center><img src="Screenshot from 2020-04-05 19-33-59.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-50-08.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-30-07.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-24-31.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-25-20.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-25-06.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-29-50.png" alt></td></tr></tbody></table><p>The maximum stable congestion window size is <code>50</code>.</p><h3 id=how-does-tcp-respond-to-the-variation-of-this-parameter>How does TCP respond to the variation of this parameter?</h3><p>Increasing the congestion window size past 100 results in no change to the graph, hence we can assume there are negligible effects to what happens to the connection.</p><p>As the congestion window size decreases, less packet loss is experiences, and at a window size of 50, no packet loss occurs, and TCP stops oscillating.</p><h3 id=what-is-the-average-throughput-in-packets-and-bps-at-this-point>What is the average throughput (in packets and bps) at this point?</h3><p>At a congestion window size of 50, the average throughput is around <code>225 packets per second</code>, or <code>225 * (500 + 20 + 20) * 8 = 972000 bps</code></p><h3 id=how-does-the-actual-average-throughput-compare-to-the-link-capacity-1mbps>How does the actual average throughput compare to the link capacity (1Mbps)?</h3><p>At the average throughput rate at a window size of 50, the link is 97.2% utilised</p><h1 id=exercise-1b-using-tcp-reno>Exercise 1b: Using TCP Reno</h1><blockquote><p>Create a congestion window graph and throughput graph for TCP Reno, using a max window size of 150, and delay of 150ms.</p></blockquote><p><img src="Screenshot from 2020-04-05 19-51-04.png" alt></p><p><img src="Screenshot from 2020-04-05 19-51-49.png" alt></p><h2 id=what-is-the-maximum-size-of-the-congestion-window-that-the-tcp-flow-reaches-in-this-case-1>What is the maximum size of the congestion window that the TCP flow reaches in this case?</h2><p>100</p><h2 id=what-does-the-tcp-flow-do-when-the-congestion-window-reaches-this-value-why-what-happens-next-1>What does the TCP flow do when the congestion window reaches this value? Why? What happens next?</h2><p>The window size is decreased to half, but not zero (TCP Reno only goes to zero when there is a timeout or three duplicate ACKs), it then drops to one afterwards and then enters a slow start and into the AIMD phase.</p><h2 id=calculate-the-average-throughput-in-packets-sec-and-bps-1>Calculate the average throughput (in packets/sec and bps)</h2><p>Average throughput is roughly <code>200 packets per sec</code>, which is <code>864000 bps</code></p><h2 id=compare-the-graphs-for-the-two-implementations-and-explain-the-differences>Compare the graphs for the two implementations and explain the differences.</h2><blockquote><p>Hint: compare the number of times the congestion window goes back to zero in each case</p></blockquote><table><thead><tr><th align=center>TCP Tahoe</th><th align=center>TCP Reno</th></tr></thead><tbody><tr><td align=center><img src="Screenshot from 2020-04-05 18-59-23.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-51-04.png" alt></td></tr><tr><td align=center><img src="Screenshot from 2020-04-05 19-17-22.png" alt></td><td align=center><img src="Screenshot from 2020-04-05 19-51-49.png" alt></td></tr><tr><td align=center>Avg: 185 pkts/s</td><td align=center>Avg: 200 pkts/s</td></tr><tr><td align=center>Avg: 799200 bps</td><td align=center>Avg: 864000 bps</td></tr></tbody></table><ul><li>Both implementations of congestion control reach the maximum congestion window size of 100.</li><li>Both implementations of congestion control, at some point, fill up the buffer queue.</li><li>Both implementations of congestion control oscillate</li><li>TCP Tahoe has large recorded dips in instantaneous throughput - TCP Reno dips in instantaneous throughput by much less</li><li>The congestion window size in TCP Tahoe goes to zero 7 times, while only once with TCP Reno</li><li>TCP Reno has a higher average throughput of 200 packets per second than TCP Tahoe (185 packets per second)</li></ul><h1 id=exercise-2-flow-fairness-with-tcp>Exercise 2: Flow Fairness with TCP</h1><p>File: <a href=tp_fairness.tcl>tp_fairness.tcl</a><br>Usage: <code>ns tp_fairness.tcl</code></p><p>File: <a href=fairness_pkt.plot>fairness_pkt.plot</a><br>Usage: <code>gnuplot fairness_pkt.plot</code></p><p><img src="Screenshot from 2020-04-05 20-08-26.png" alt></p><h2 id=does-each-flow-get-an-equal-share-of-the-capacity-of-the-common-link-i-e-is-tcp-fair>Does each flow get an equal share of the capacity of the common link (i.e., is TCP fair)?</h2><blockquote><p>Explain which observations lead you to this conclusion.</p></blockquote><p>Each share <strong>does</strong> get an equal share of the capacity of the link.<br>We can deduce this as all of the lines of the graph are closely clustered together.</p><p>In more detail, at <code>t=0</code> to <code>t=5s</code>, flow (2-3) is the sole activity in the link, and having 100% of the link capacity, we can assume the capacity of the link to be the recorded throughput of around 120 packets per second.</p><p>After <em>t=25s</em>, the average lines for all of the flows vary around the throughput rate of around 25.<br>Dividing 120 packets per second by 5 flows, <code>120 / 5 = 24 packets per second</code> per flow.</p><p>Hence, as each flow has an average throughput (~25 packets per second) around this equally portioned capacity (24 packets per second), we can conclude that each flow gets an equal share of capacity, and that TCP is fair.</p><h2 id=what-happens-to-the-throughput-of-the-pre-existing-tcp-flows-when-a-new-flow-is-created-explain-the-mechanisms-of-tcp-which-contribute-to-this-behaviour-argue-about-whether-you-consider-this-behaviour-to-be-fair-or-unfair>What happens to the throughput of the pre-existing TCP flows when a new flow is created? Explain the mechanisms of TCP which contribute to this behaviour. Argue about whether you consider this behaviour to be fair or unfair.</h2><p><strong>Note: Modifying the number of flows from 5, to 10</strong></p><p><img src="Screenshot from 2020-04-05 20-26-58.png" alt></p><ul><li>When a new flow is created, the throughput of other existing flows are negatively affected (throughput decreases).<br></li><li>Some flows are unable to transmit, as seen by the throughput rate being recorded at 0 packets per second.<br></li><li>Each flow no longer has an average throughput of the previous 24 pkts/s, rather they now have an average throughput of around 16 pkts/s</li><li>As the number of flows increase, the average throughput will decrease.<br></li></ul><p>TCP packets may be purposely dropped to allow packets to be received from other nodes.</p><p>This behaviour can be considered <strong>fair to the new flow</strong> (everyone - including the new flow - is able to transmit, even if only a little bit), <strong>but unfair to existing flows</strong> (throughput decreases).</p><h1 id=exercise-3-tcp-competing-with-udp>Exercise 3: TCP competing with UDP</h1><p>File: <a href=tp_TCPUDP.tcl>tp_TCPUDP.tcl</a><br>Usage: <code>ns tp_TCPUDP &lt;link_capacity&gt;</code></p><p>File: <a href=TCPUDP_pps.plot>TCPUDP_pps.plot</a><br>Usage: <code>gnuplot TCPUDP_pps.plot</code></p><h2 id=how-do-you-expect-the-tcp-flow-and-the-udp-flow-to-behave-if-the-capacity-of-the-link-is-5-mbps>How do you expect the TCP flow and the UDP flow to behave if the capacity of the link is 5 Mbps?</h2><ul><li>TCP packets will assess the current free capacity of the link and rate control its packets.</li><li>UDP packets will dominate the link capacity, and will bombard the link without considering its rate.</li><li>UDP packets will be sent at a much faster rate than TCP packets will.</li></ul><h2 id=test-your-hypothesis>Test your hypothesis</h2><blockquote><p>Run the command: <code>ns tp_TCPUDP.tcl 5Mb</code> and <code>gnuplot TCPUDP_pps.plot</code></p></blockquote><p><img src="Screenshot from 2020-04-05 20-53-13.png" alt></p><p>The <span style=color:red>RED</span> packets can be identified as UDP packets, as they are transmitted continuously in masses.<br>The <span style=color:blue>BLUE</span> packets can be identified as TCP packets, as they are transmitted sparingly.</p><p><img src="Screenshot from 2020-04-05 20-49-37.png" alt></p><p>Yep. UDP packets are being sent out, with throughput in the range of 900-1100 pkts/s.<br>TCP packets are only being transmitted at an average rate of around 130 pkts/s.</p><h2 id=why-does-one-flow-achieve-higher-throughput-than-the-other-try-to-explain-what-mechanisms-force-the-two-flows-to-stabilise-to-the-observed-throughput>Why does one flow achieve higher throughput than the other? Try to explain what mechanisms force the two flows to stabilise to the observed throughput.</h2><p>The TCP protocol implements congestion control, using its slow start and AIMD algorithms to find a stable transmission rate. The UDP protocol however, does not implement rate controlling, and hence it does not care about congestion in the link, and simply fires as many packets as it can; regardless if the link is full or not. This is why UDP packets are being transmitted at a higher throughput than the TCP packets.</p><p>Factors contributing towards the stabilisation of the throughput for the flows (rather than there being an infinite throughput), is the size of the transmission buffer, and the rate at which data can be modulated and transmitted over the wire.</p><h2 id=list-the-advantages-and-the-disadvantages-of-using-udp-instead-of-tcp-for-a-file-transfer-when-our-connection-has-to-compete-with-other-flows-for-the-same-link-what-would-happen-if-everybody-started-using-udp-instead-of-tcp-for-that-same-reason>List the advantages and the disadvantages of using UDP instead of TCP for a file transfer, when our connection has to compete with other flows for the same link. What would happen if everybody started using UDP instead of TCP for that same reason?</h2><h3 id=advantages-udp-for-file-transfer>Advantages | UDP for file transfer</h3><ul><li>Higher throughput (more data transmitted)</li><li>Doesn&rsquo;t consider other activity in the network, so doesn&rsquo;t limit the rate of transmission (&ldquo;priority&rdquo;)</li><li>Fast!</li></ul><h3 id=disadvantages-udp-for-file-transfer>Disadvantages | UDP for file transfer</h3><ul><li>Packets may not be sent</li><li>Packets may be lost</li><li>No bit error correction - packet needs to be retransmitted</li><li>Will need to implement a structure to manage the order of file segments</li><li>Will need to implement a structure to manage which file segments have [not] been received ([n]ACK)</li></ul><hr><p>If everyone used UDP instead of TCP, we would run into a lot of packet loss.<br>The link will probably still be heavily utilised, but many more packets will be dropped from each user, and the individual throughput of each user will decrease</p></div><footer class=post-footer><nav class=post-nav><a class=prev href=../../post/lab04/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Lab 04 - Exploring TCP</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=../../post/lab06/><span class="next-text nav-default">Lab 06 - Throughput, IP Fragmentation and Routing</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:z5206677@student.unsw.edu.au class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/andrewjinmengwong/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/featherbear class="iconfont icon-github" title=github></a><a href=https://www.instagram.com/_andrewjwong/ class="iconfont icon-instagram" title=instagram></a><a href=../../index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Andrew Wong (z5206677)</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=../../dist/even.26188efa.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-107434487-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=../../js/typed.js@2.0.9></script><script src=../../js/typedjs.shortcode.js></script></body></html>