<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>TCP Protocol - COMP3331 Musings</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content=z5206677><meta name=description content="Stream of bytes that will arrive in the right order  Segments A large TCP packet is split into segments to allow it to be transmitted over the wire."><meta name=keywords content=Hugo,theme,even><meta name=generator content="Hugo 0.58.2 with theme even"><link rel=canonical href=../../post/tcp/><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../manifest.json><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><link href=../../dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=../../css/typedjs.shortcode.css><meta property=og:title content="TCP Protocol"><meta property=og:description content="Stream of bytes that will arrive in the right order  Segments A large TCP packet is split into segments to allow it to be transmitted over the wire."><meta property=og:type content=article><meta property=og:url content=/post/tcp/><meta property=article:published_time content=2020-04-25T00:30:51+10:00><meta property=article:modified_time content=2020-04-25T00:30:51+10:00><meta itemprop=name content="TCP Protocol"><meta itemprop=description content="Stream of bytes that will arrive in the right order  Segments A large TCP packet is split into segments to allow it to be transmitted over the wire."><meta itemprop=datePublished content=2020-04-25T00:30:51&#43;10:00><meta itemprop=dateModified content=2020-04-25T00:30:51&#43;10:00><meta itemprop=wordCount content=1027><meta itemprop=keywords content><meta name=twitter:card content=summary><meta name=twitter:title content="TCP Protocol"><meta name=twitter:description content="Stream of bytes that will arrive in the right order  Segments A large TCP packet is split into segments to allow it to be transmitted over the wire."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=../../ class=logo>COMP3331 Musings</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=../../><li class=mobile-menu-item>Home</li></a><a href=https://github.com/featherbear/UNSW-COMP3331><li class=mobile-menu-item>GitHub</li></a><a href=../../categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=../../ class=logo>COMP3331 Musings</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=../../>Home</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/featherbear/UNSW-COMP3331>GitHub</a></li><li class=menu-item><a class=menu-item-link href=../../categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>TCP Protocol</h1><div class=post-meta><span class=post-time>2020-04-25</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#segments>Segments</a></li><li><a href=#structure>Structure</a></li><li><a href=#sequence-number>Sequence Number</a></li><li><a href=#ack-sequence-number>ACK Sequence Number</a></li><li><a href=#packet-piggybacking>Packet Piggybacking</a></li><li><a href=#tcp-packet-buffer>TCP Packet Buffer</a><ul><li><a href=#rtt-time-and-timeout>RTT Time and Timeout</a></li></ul></li><li><a href=#tcp-fast-retransmit>TCP Fast Retransmit</a></li><li><a href=#flow-control>Flow Control</a></li><li><a href=#connection-management>Connection Management</a><ul><li><a href=#three-way-handshake>Three Way Handshake</a></li><li><a href=#lost-syn-packets>Lost <code>SYN</code> packets</a></li><li><a href=#closing-connections>Closing Connections</a></li><li><a href=#abrupt-termination>Abrupt Termination</a></li></ul></li><li><a href=#tcp-syn-attack-syn-flooding>TCP SYN Attack (SYN Flooding)</a><ul><li><a href=#mitigation-techniques>Mitigation Techniques</a></li></ul></li><li><a href=#tcp-syn-cookies>TCP SYN Cookies</a></li><li><a href=#congestion-control>Congestion Control</a><ul><li><a href=#rate-adjustment>Rate Adjustment</a></li><li><a href=#tcp-slow-start-bandwidth-discovery>TCP Slow Start (Bandwidth Discovery)</a></li><li><a href=#additive-increase-multiplicative-decrease-aimd>Additive Increase Multiplicative Decrease (<code>AIMD</code>)</a></li><li><a href=#steady-state-threshold-ssthresh>Steady State Threshold (<code>ssthresh</code>)</a></li><li><a href=#tcp-reno-new>TCP Reno (New)</a></li><li><a href=#tcp-tahoe-old>TCP Tahoe (Old)</a></li></ul></li></ul></nav></div></div><div class=post-content><ul><li>Stream of bytes that will arrive in the right order</li></ul><h1 id=segments>Segments</h1><p>A large TCP packet is split into segments to allow it to be transmitted over the wire.</p><p>The largest packet size, according to the Ethernet protocol is 1500 bytes; this is known as the MTU.</p><p>IP layer requires at least 20 bytes for its header.<br>TCP layer requires at least 20 bytes for its header.<br>As OSI layers encapsulate each other, the maximum size of a TCP packet is 1460 bytes.</p><ul><li><strong>Maximum Transmission Unit (MTU)</strong> - Up to 1500 bytes with Ethernet</li><li><strong>Maximum Segment Size (MSS)</strong> - Up to 1460 bytes (MTU - 20 - 20)</li></ul><h1 id=structure>Structure</h1><p><strong>Header</strong></p><ul><li>2 bytes - Source port</li><li>2 bytes - Destination port</li><li>4 bytes - Sequence number</li><li>4 bytes - Acknowledgement</li><li>2 bytes - Flags</li><li>2 bytes - Receive Window</li><li>2 bytes - Checksum</li><li>2 bytes - Urgent Pointer</li><li>Optional n bytes - Options</li></ul><p><strong>Payload</strong></p><h1 id=sequence-number>Sequence Number</h1><p>The sequence number of a TCP segment is the position of the first byte in the segment.</p><p>SeqNo = ISN + K</p><h1 id=ack-sequence-number>ACK Sequence Number</h1><p>The acknowledgement number is the <strong>next byte</strong> the client accepting from the other host</p><p>ACKNo = SeqNo + Length</p><p>If a packet is lost and later packets arrive, the receiving will keep sending the ACK for the byte number of the lost packet. <a href=#tcp-packet-buffer>Refer to TCP Packet Buffer</a></p><hr><p><strong>Example</strong></p><p><img src="Screenshot from 2020-04-25 00-39-35.png" alt></p><p><code>Seq=42, ACK=79, data='C'</code> -&gt; This packet is byte #42, I am next expecting the reply with <code>Seq=79</code></p><h1 id=packet-piggybacking>Packet Piggybacking</h1><p>Multiple packet payloads within the same packet.</p><p><em>i.e. Response + ACK</em></p><h1 id=tcp-packet-buffer>TCP Packet Buffer</h1><p><img src="Screenshot from 2020-04-25 00-45-46.png" alt></p><h2 id=rtt-time-and-timeout>RTT Time and Timeout</h2><p><img src="Screenshot from 2020-04-25 00-54-04.png" alt></p><ul><li>If timeout too short - premature timeout, unnecessary retransmission</li><li>If timeout too long - slow reaction to segment loss and lower throughput</li></ul><p>Solution: Maths.</p><p>SampleRTT - Time from segment transmission until last ACK receipt (ignore retransmission).</p><ul><li><strong>EstimatedRTT = (1-α) * EstimatedRTT_prev + α*SampleRTT</strong></li><li><strong>DevRTT = (1-ß)*DevRTT + ß*|SampleRTT-EstimatedRTT|</strong></li><li><strong>Timeout Interval = EstimatedRTT + 4*DevRTT</strong></li></ul><p>Where there is a safety margin to allow for deviations in the EstimatedRTT.</p><ul><li><code>α = 0.125</code></li><li><code>ß = 0.25</code></li></ul><h1 id=tcp-fast-retransmit>TCP Fast Retransmit</h1><p>Duplicate ACKs to trigger early retransmission.</p><p>Trigger: Triple Duplicate ACK - When the same ACK is received 4 times (3 times extra).</p><p>This mechanism bypasses the timeout (Which is often relatively long)</p><h1 id=flow-control>Flow Control</h1><p>Sockets usually have a <code>RcvBuffer</code> value of 4096 bytes.<br>This controls the size of the buffer.</p><p>The <strong>Receive Window</strong> (<code>rwnd</code>) value in the TCP header field of receiver-to-sender segments is the free space of the RcvBuffer.</p><p>By sending the size of the free space in the buffer, the sender will be ensured that the next data they transmit will not overflow the receiver&rsquo;s buffer</p><h1 id=connection-management>Connection Management</h1><ul><li>Handshake - Agreement on connection and connection parameters.</li></ul><h2 id=three-way-handshake>Three Way Handshake</h2><ul><li>Client sends <code>TCP SYN</code> (contains initial sequence number <code>x</code>)</li><li>Server sends <code>TCP SYNACK</code> (contains their own initial sequence number <code>y</code>) <code>ACKNo=x+1</code></li><li>Client sends <code>TCP ACK</code> <code>ACKNo=y+1</code></li></ul><h2 id=lost-syn-packets>Lost <code>SYN</code> packets</h2><p>There is a timer (usually 3 seconds) that waits for a SYNACK.<br>It will retransmit if needed.</p><p>A SYN could also be transmitted quickly by creating a new connection</p><h2 id=closing-connections>Closing Connections</h2><p>When the FIN bit in a packet is sent, the host can no longer transmit data <em>(*)</em>.<br>It can however, still receive data</p><p><em>*: ACK packets are not counted as data, and can still be sent</em></p><ul><li>A sends TCP segment with <code>FIN=1</code></li><li>B sends <code>ACK</code> and possibly its own <code>FIN</code></li><li>A sends <code>ACK</code></li></ul><h2 id=abrupt-termination>Abrupt Termination</h2><ul><li>A sends a reset packet <code>RST</code> to B to tell B to stop communicating</li><li>B does not acknowledge the <code>RST</code> packet</li><li>A will keep transmitting <code>RST</code> packets for each reply it keeps receiving from <code>B</code></li></ul><h1 id=tcp-syn-attack-syn-flooding>TCP SYN Attack (SYN Flooding)</h1><p>The SYN Flooding attack causes a server to accept spoofed connections, wasting server resources.<br>Whilst the server will eventually close and garbage collect the socket, large numbers of spoofed SYN packets will overwhelm the server, increasing server load.</p><h2 id=mitigation-techniques>Mitigation Techniques</h2><ul><li>Increase connection queue size</li><li>Decrease timeout time for the 3 way handshake</li><li>Firewalls</li><li>TCP SYN Cookies</li></ul><h1 id=tcp-syn-cookies>TCP SYN Cookies</h1><p>The initial sequence number (hash of source and destination IP and ports) is used as a secret key for a hash.</p><p>When receiving a <code>SYN</code>, the server will reply with a <code>SYNACK</code> containing this initial sequence number (key).<br>The client will then have to reply with an <code>ACK</code>, checking that the ACK is equal to the initial sequence number + 1.<br>Only if this check is true will the server create the connection.</p><p>This stops attackers from sending many SYN packets - instead they must wait for the server&rsquo;s <code>SYNACK</code>, and send a second packet (ACK) with the right details</p><h1 id=congestion-control>Congestion Control</h1><p>Congestion increases delivery latency, loss rate, and leads to retransmissions.</p><p><img src="Screenshot from 2020-04-25 23-49-37.png" alt></p><ul><li>Knee Point - Point where throughput increases slowly, decay increases fast</li><li><p>Cliff Point - Point where throughput drops to zero (Congestion collapse), decay approaches infinity</p></li><li><p>End to End Congestion Control</p><ul><li>Congestion inferred from observed loss and delay</li></ul></li><li><p>Network-asssited Congestion Control</p><ul><li>Feedback from networking infrastructure</li><li>DNA, DECbit, TCP/IP ECN, ATM</li><li>Authoritative transmission rate</li></ul></li><li><p>TCP Send Rate is roughly (cwnd / RTT) (bytes/sec)</p></li><li><p>Congestion Window (<code>cwnd</code>) - How many bytes can be sent without overflowing routers</p><ul><li>Computed by the sender using algorithms</li></ul></li><li><p>Receive Window (<code>rwnd</code>) - How many bytes can be sent without overflowing the receiver&rsquo;s buffers</p><ul><li>Determined by the receiver (notified to the sender)</li></ul></li><li><p>Sender-size window: <code>min(cwnd,rwnd)</code></p></li></ul><h2 id=rate-adjustment>Rate Adjustment</h2><ul><li>When ACK (of new data) is received, increase rate</li><li>When loss is detected, decrease rate</li></ul><p>TCP incorporates two algorithms, TCP Slow Start then AIMD.</p><h2 id=tcp-slow-start-bandwidth-discovery>TCP Slow Start (Bandwidth Discovery)</h2><p>Increase transmission rate exponentially (doubled) until the first loss event.</p><ul><li>Initial rate slow, but ramps up exponentially</li></ul><h2 id=additive-increase-multiplicative-decrease-aimd>Additive Increase Multiplicative Decrease (<code>AIMD</code>)</h2><ul><li>Additive Increase - Increases <code>cwnd</code> every RTT (ACK received) until loss detected</li><li>Multiplicative Decrease - Half the <code>cwnd</code></li></ul><hr><h2 id=steady-state-threshold-ssthresh>Steady State Threshold (<code>ssthresh</code>)</h2><p>The steady state threshold is the <code>cwnd</code> value which will trigger the protocol to change from TCP Slow Start to AIMD.<br>This is often set to some high value, and is decreased (by means of halving) on loss</p><h2 id=tcp-reno-new>TCP Reno (New)</h2><ul><li>cwnd = 1 on timeout</li><li>cwnd = cwnd/2 on triple duplicate ACK (TCP fast retransmit)</li></ul><h2 id=tcp-tahoe-old>TCP Tahoe (Old)</h2><ul><li>cwnd = 1 on timeout and triple duplicate ACK</li></ul></div><footer class=post-footer><nav class=post-nav><a class=prev href=../../post/transport-layer/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Transport Layer</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=../../post/network-layer-and-ip/><span class="next-text nav-default">Network Layer || IP Addressing</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article><script>(function(f,a,t,h,o,m){a[h]=a[h]||function(){(a[h].q=a[h].q||[]).push(arguments)};o=f.createElement('script'),m=f.getElementsByTagName('script')[0];o.async=1;o.src=t;o.id='fathom-script';m.parentNode.insertBefore(o,m)})(document,window,'//ss.featherbear.cc/tracker.js','fathom');fathom('set','siteId','NEQTU');fathom('trackPageview');</script></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:z5206677@student.unsw.edu.au class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/andrewjinmengwong/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/featherbear class="iconfont icon-github" title=github></a><a href=https://www.instagram.com/_andrewjwong/ class="iconfont icon-instagram" title=instagram></a><a href=../../index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2021
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Andrew Wong (z5206677)</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=../../dist/even.26188efa.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-107434487-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=../../js/typed.js@2.0.9></script><script src=../../js/typedjs.shortcode.js></script></body></html>